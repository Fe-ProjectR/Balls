--[[
LeashTool with drooping rope (client-side executable)
- Visual-only drooping rope made from segments + beams (no physics force).
- Player unaffected by rope (no tug).
- NPC following uses Humanoid:MoveTo (skips while jumping).
Paste into your executor and run.
--]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
if not player then return end
local backpack = player:WaitForChild("Backpack")

-- CONFIG
local NUM_SEGMENTS = 6       -- number of droop segments between endpoints
local SAG_AMOUNT = 2         -- how many studs the rope sags at the middle (positive number)
local BEAM_WIDTH = 0.12
local FOLLOW_TICK = 0.18     -- how often npc MoveTo is triggered (seconds)
local BEAM_SMOOTH_UPDATE = true -- use RenderStepped for smooth visual updates

-- Create tool if missing
local function makeTool()
    local tool = Instance.new("Tool")
    tool.Name = "LeashTool"
    tool.CanBeDropped = false
    tool.RequiresHandle = true

    local handle = Instance.new("Part")
    handle.Name = "Handle"
    handle.Size = Vector3.new(1,1,1)
    handle.Transparency = 0.6
    handle.Anchored = false
    handle.CanCollide = false
    handle.Parent = tool

    tool.Parent = backpack
    return tool
end

local tool = backpack:FindFirstChild("LeashTool") or makeTool()

-- Helper functions
local function findLeftArm(character)
    local names = {"LeftLowerArm","LeftUpperArm","Left Arm","LeftHand","LeftHandAttachment"}
    for _,n in ipairs(names) do
        local p = character:FindFirstChild(n, true)
        if p and p:IsA("BasePart") then return p end
    end
    if character.PrimaryPart and character.PrimaryPart:IsA("BasePart") then
        return character.PrimaryPart
    end
    for _,v in pairs(character:GetChildren()) do
        if v:IsA("BasePart") then return v end
    end
    return nil
end

local function findNPCTorso(npc)
    local try = {"UpperTorso","Torso","HumanoidRootPart"}
    for _,n in ipairs(try) do
        local p = npc:FindFirstChild(n, true)
        if p and p:IsA("BasePart") then return p end
    end
    if npc.PrimaryPart and npc.PrimaryPart:IsA("BasePart") then return npc.PrimaryPart end
    for _,v in pairs(npc:GetChildren()) do
        if v:IsA("BasePart") then return v end
    end
    return nil
end

local function getNPCFromTarget(target)
    if not target then return nil end
    local model = target:FindFirstAncestorOfClass("Model")
    if not model then return nil end
    if Players:GetPlayerFromCharacter(model) then return nil end
    if not model:FindFirstChildOfClass("Humanoid") then return nil end
    return model
end

local function createCollar(npc, torsoPart)
    if not torsoPart then return nil end
    local collar = Instance.new("Part")
    collar.Name = "LeashCollar"
    collar.Size = Vector3.new(0.6, 0.18, 0.6)
    collar.Shape = Enum.PartType.Cylinder
    collar.CanCollide = false
    collar.Anchored = false
    collar.Material = Enum.Material.SmoothPlastic
    collar.Color = Color3.fromRGB(255,170,0)
    collar.Parent = npc
    collar.CFrame = torsoPart.CFrame * CFrame.new(0, 0.5, 0) * CFrame.Angles(0,0,math.rad(90))
    local weld = Instance.new("WeldConstraint")
    weld.Part0 = collar
    weld.Part1 = torsoPart
    weld.Parent = collar
    return collar
end

-- Main leash storage:
-- leashes[npc] = {
--   AttachmentPlayer = attP,
--   AttachmentNPC = attN,
--   SegmentParts = {part1, part2, ...},
--   SegmentAttachments = {att1, att2, ...},
--   Beams = {beam1, beam2, ...},
--   BeamHolder = folder,
--   Collar = part,
--   Connection = followConn,
--   Updater = renderConn (optional)
-- }
local leashes = {}

-- Create segments + beams chain between attP and attN
local function createDroopChain(attP, attN, numSegments, sag)
    local holder = Instance.new("Folder")
    holder.Name = "LeashChainHolder"
    holder.Parent = Workspace

    local segParts = {}
    local segAttachments = {}

    -- create anchored invisible parts for attachments
    for i = 1, numSegments do
        local p = Instance.new("Part")
        p.Name = "LeashSeg"
        p.Size = Vector3.new(0.2, 0.2, 0.2)
        p.Anchored = true    -- anchored so it doesn't apply physics
        p.CanCollide = false
        p.Transparency = 1   -- invisible
        p.Parent = holder

        local att = Instance.new("Attachment")
        att.Name = "LeashSegAtt_" .. tostring(i)
        att.Parent = p

        segParts[i] = p
        segAttachments[i] = att
    end

    -- build attachment list: attP, segAtt1..segAttN, attN
    local attList = {}
    table.insert(attList, attP)
    for _,a in ipairs(segAttachments) do table.insert(attList, a) end
    table.insert(attList, attN)

    -- create beams for each adjacent pair
    local beams = {}
    for i = 1, #attList - 1 do
        local beam = Instance.new("Beam")
        beam.Name = "LeashBeam_" .. tostring(i)
        beam.Attachment0 = attList[i]
        beam.Attachment1 = attList[i+1]
        beam.Width0 = BEAM_WIDTH
        beam.Width1 = BEAM_WIDTH
        beam.FaceCamera = false
        beam.Transparency = NumberSequence.new(0)
        beam.LightEmission = 0.2
        beam.Parent = holder
        beams[i] = beam
    end

    return {
        Holder = holder;
        SegmentParts = segParts;
        SegmentAttachments = segAttachments;
        Beams = beams;
        AttachmentList = attList;
    }
end

-- Parabolic sag function (returns vertical offset relative to straight line)
local function sagOffsetY(t, sag)
    -- t in [0,1], sag > 0 (studs). Middle gets -sag (down), ends 0.
    -- formula: offsetY = -sag * (1 - 4*(t-0.5)^2)
    local v = 1 - 4 * (t - 0.5) * (t - 0.5)
    return -sag * v
end

-- Position segment parts along the sag curve between p0 and p1
local function updateDroopPositions(attP, attN, segParts, numSegments, sag)
    local p0 = attP.WorldPosition
    local p1 = attN.WorldPosition
    for i = 1, numSegments do
        local t = i / (numSegments + 1)
        local interp = p0:Lerp(p1, t)
        local dropY = sagOffsetY(t, sag)
        local pos = Vector3.new(interp.X, interp.Y + dropY, interp.Z)
        -- set anchored part position
        local part = segParts[i]
        if part and part.Parent then
            part.CFrame = CFrame.new(pos)
        end
    end
end

-- Add leash (main)
local function addLeash(npc)
    if not npc or not npc.Parent then return end
    if leashes[npc] then return end

    local character = player.Character or player.CharacterAdded:Wait()
    local leftArm = findLeftArm(character)
    if not leftArm then return end

    local torsoPart = findNPCTorso(npc)
    if not torsoPart then return end

    -- Attachments: player side BELOW left arm, npc side TOP of torso
    local attP = Instance.new("Attachment")
    attP.Name = "Leash_Att_P"
    attP.Parent = leftArm
    attP.Position = Vector3.new(0, -0.9, 0)

    local attN = Instance.new("Attachment")
    attN.Name = "Leash_Att_N"
    attN.Parent = torsoPart
    attN.Position = Vector3.new(0, 0.65, 0)

    -- drooping chain
    local chain = createDroopChain(attP, attN, NUM_SEGMENTS, SAG_AMOUNT)

    -- create collar
    local collar = createCollar(npc, torsoPart)

    -- initial position update
    updateDroopPositions(attP, attN, chain.SegmentParts, NUM_SEGMENTS, SAG_AMOUNT)

    -- smooth visual updater (RenderStepped) to keep segments following each frame
    local renderConn
    if BEAM_SMOOTH_UPDATE then
        renderConn = RunService.RenderStepped:Connect(function()
            -- update all segment part positions based on current world endpoints
            updateDroopPositions(attP, attN, chain.SegmentParts, NUM_SEGMENTS, SAG_AMOUNT)
        end)
    else
        -- fallback: Heartbeat at 60fps (less ideal)
        renderConn = RunService.Heartbeat:Connect(function()
            updateDroopPositions(attP, attN, chain.SegmentParts, NUM_SEGMENTS, SAG_AMOUNT)
        end)
    end

    -- Follow logic (throttled)
    local humanoid = npc:FindFirstChildOfClass("Humanoid")
    local root = npc:FindFirstChild("HumanoidRootPart") or npc.PrimaryPart
    local accumulator = 0
    local conn
    conn = RunService.Heartbeat:Connect(function(dt)
        accumulator = accumulator + dt

        -- also keep segments updated at a slower rate in case RenderStepped disabled
        if not BEAM_SMOOTH_UPDATE then
            updateDroopPositions(attP, attN, chain.SegmentParts, NUM_SEGMENTS, SAG_AMOUNT)
        end

        if accumulator >= FOLLOW_TICK then
            accumulator = 0
            -- safety checks
            if not player or not player.Character or not player.Character.PrimaryPart then
                if conn and conn.Connected then conn:Disconnect() end
                return
            end
            if not npc or not npc.Parent then
                if conn and conn.Connected then conn:Disconnect() end
                return
            end
            if not humanoid or not root then return end

            -- skip if player is jumping/falling to avoid tug effect while airborne
            local playerHumanoid = player.Character:FindFirstChildOfClass("Humanoid")
            local skipMove = false
            if playerHumanoid then
                local state = playerHumanoid:GetState()
                if state == Enum.HumanoidStateType.Jumping or state == Enum.HumanoidStateType.Freefall or state == Enum.HumanoidStateType.FallingDown then
                    skipMove = true
                end
            end

            if not skipMove then
                local charPP = player.Character.PrimaryPart
                local behindOffset = charPP.CFrame.LookVector * 3
                local desired = charPP.Position - behindOffset
                desired = Vector3.new(desired.X, root.Position.Y, desired.Z)
                local dist = (charPP.Position - root.Position).Magnitude
                local minDistance = 3.2
                if dist < minDistance then
                    desired = charPP.Position - charPP.CFrame.LookVector * (minDistance + 0.5)
                    desired = Vector3.new(desired.X, root.Position.Y, desired.Z)
                end
                if (charPP.Position - root.Position).Magnitude > (minDistance + 0.5) then
                    pcall(function() humanoid:MoveTo(desired) end)
                else
                    pcall(function() humanoid:MoveTo(root.Position) end)
                end
            end
        end
    end)

    -- Save leash data
    leashes[npc] = {
        AttachmentPlayer = attP;
        AttachmentNPC = attN;
        SegmentParts = chain.SegmentParts;
        SegmentAttachments = chain.SegmentAttachments;
        Beams = chain.Beams;
        BeamHolder = chain.Holder;
        Collar = collar;
        Connection = conn;
        RenderUpdater = renderConn;
    }
end

-- Remove leash
local function removeLeash(npc)
    local data = leashes[npc]
    if not data then return end
    if data.Connection and data.Connection.Connected then data.Connection:Disconnect() end
    if data.RenderUpdater and data.RenderUpdater.Connected then data.RenderUpdater:Disconnect() end
    if data.BeamHolder and data.BeamHolder.Parent then data.BeamHolder:Destroy() end
    if data.AttachmentPlayer and data.AttachmentPlayer.Parent then data.AttachmentPlayer:Destroy() end
    if data.AttachmentNPC and data.AttachmentNPC.Parent then data.AttachmentNPC:Destroy() end
    if data.Collar and data.Collar.Parent then data.Collar:Destroy() end
    leashes[npc] = nil
end

local function toggleLeash(npc)
    if not npc then return end
    if leashes[npc] then
        removeLeash(npc)
    else
        addLeash(npc)
    end
end

local function removeAllLeashes()
    for n,_ in pairs(leashes) do
        removeLeash(n)
    end
end

-- Tool events
local mouse = player:GetMouse()

tool.Equipped:Connect(function()
    -- nothing special on equip
end)
tool.Unequipped:Connect(function()
    -- keep leashes when unequipped (per your request)
end)

tool.Activated:Connect(function()
    local target = mouse.Target
    local npc = getNPCFromTarget(target)
    if not npc then return end
    toggleLeash(npc)
end)

player.CharacterAdded:Connect(function(newChar)
    -- keep leashes by default; if you want them cleared on death uncomment:
    -- removeAllLeashes()
end)

-- Hotkey to clear all leashes (L)
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.L then
        removeAllLeashes()
    end
end)

print("[LeashTool] Executed. Drooping rope active. Equip and click NPCs to leash/unleash.")
