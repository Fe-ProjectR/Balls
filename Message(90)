local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local LocalPlayer = Players.LocalPlayer

pcall(function()
	StarterGui:SetCore("SendNotification", {
		Title = "FE Backshot";
		Text = "Credits to @c_s911 for this, he the goat fr";
		Duration = 6;
	})
end)

-- behavior controls [prettymuch when the script is executed these eill be automatically activatef]
local BEHAVIORS = {
	ENABLE_BACK_MOVEMENT = true,
	ENABLE_FRONT_MOVEMENT = true,
	ENABLE_INCHING = true,
	ENABLE_PATTERN_DETECTION = true,
	ENABLE_ITEM_HANDLING = true,
	ENABLE_SEAT_HANDLING = true,
	ENABLE_BOOMBOX = true,
	ENABLE_AUTO_TARGET = false,
}

local BOOMBOX_CONFIG = {
	RADIUS = 4,
	SOUND_ID = "6644572826",
	CHECK_INTERVAL = 0.5,
	GRIP_POS = Vector3.new(-8.5, 0, 0),
	lastBoomBoxCheck = 0,
	currentBoomBox = nil,
	toolAnimTrack = nil,
	animationConnection = nil,
	animatorConnection = nil
}

local ITEMS_TO_EQUIP = {
	"Pizza",
	"Burger",
	"Newspaper",
	"Soda",
}

-- Configuration area
local timeout = 0.01
local IGNORE_GAZE_CHANCE = 0.3
local LOOKAT_CHANCE = 0.45
local LOOKAWAY_CHANCE = 0.6
local RADIUS = 3
local TARGET_SWITCH_TIME_MIN = 10
local TARGET_SWITCH_TIME_MAX = 30
local BACK_DISTANCE = 4
local FRONT_DISTANCE = 4
local CLOSE_DISTANCE_MIN = 0.1
local CLOSE_DISTANCE_MAX = 0.25
local LOOK_DETECTION_RADIUS = 20
local LOOK_ANGLE_THRESHOLD = math.rad(85)
local MINIMUM_DISTANCE_TO_TARGET = 2
local INCH_AMOUNT = 2
local INCH_INTERVAL_MIN = 0.1
local INCH_INTERVAL_MAX = 2
local INITIAL_WAIT_MIN = 0.5
local INITIAL_WAIT_MAX = 5
local ITEM_SWITCH_INTERVAL_MIN = 5
local ITEM_SWITCH_INTERVAL_MAX = 15
local TOOL_ACTIVATE_CHANCE = 0.3
local TOOL_ACTIVATE_CHECK_INTERVAL = 1
local REVERSE_BEHAVIOR_CHANCE = 0.3
local BACKWARDS_INCH_AMOUNT = 2
local BACKWARDS_MINIMUM_DISTANCE = 8
local FRONT_MOVEMENT_CHANCE = 0.05
local REACTION_CHANCE = 0.5

local PATTERN_DETECTION = {
	CHECK_INTERVAL = 0.5,
	HISTORY_LENGTH = 10,
	THRESHOLD = 4,
	SMALL_RANGE = {min = 0.1, max = 1},
	LARGE_RANGE = {min = 3, max = 4},
	TARGET_SWITCH_DELAY = 5,
	MOVEMENT_CHECK_INTERVAL = 0.5,
	PATTERN_THRESHOLD = 3,
	DIRECTION_CHANGE_THRESHOLD = 2,
	NEARBY_PLAYER_RADIUS = 15
}

local MINIMUM_DISTANCE_BEHAVIOR = {
	FRONT_MOVEMENT_SWITCH_CHANCE = 0.3,
	FACING_NOD_COOLDOWN = 3,
	lastFacingNod = 0
}

local STUCK_DETECTION = {
	VELOCITY_THRESHOLD = 0.1,
	CHECK_INTERVAL = 0.5,
	STUCK_DURATION = 1.0,
	LAST_POSITION = nil,
	LAST_CHECK_TIME = 0,
	STUCK_START_TIME = 0,
	IS_STUCK = false,
	JUMP_COOLDOWN = 1.5,
	LAST_FORCED_JUMP = 0
}

local RAYCAST_CONFIG = {
	DISTANCE = 3.5,
	HEIGHT_OFFSET = 2,
	CHECK_INTERVAL = 0.05,
	JUMP_COOLDOWN = 0.3,
	FILTER_TYPE = Enum.RaycastFilterType.Exclude
}

local isMovingBack = true
local isMoving = false
local beingLookedAt = false
local isInchingEnabled = false
local isReverseBehavior = false
local isFrontMovementEnabled = false
local isJumping = false
local isMovingForward = false
local isMovingBackward = false
local lastInchTime = 0
local inchingInProgress = false
local currentEquippedItem = nil
local lastItemSwitch = 0
local lastActivateCheck = 0
local lastSeatChange = 0
local lastMovementCheck = 0
local movementHistory = {}
local smallRangeCount = 0
local largeRangeCount = 0
local lastTargetPosition = nil
local lastJumpAttempt = 0
local jumpAttemptsCount = 0
local currentTarget = nil
local currentBehaviorState = "none"
local lastTargetSwitch = 0
local targetSwitchDelay = 0
local playerMovementHistory = {}
local lastPatternCheck = 0
local lastJumpTime = 0
local DEBUG_TARGET_PLAYER_NAME = "ballgobler820"
local DEBUG_MODE = true
local targetReferencePart = nil

local manualTargetSelected = false
local preferredShotMode = "back" -- "back" or "front"

local debugTextLabel = nil
local behaviorScreenGui = nil
local giveBackToolBtn = nil
local giveFrontToolBtn = nil
local clearTargetBtn = nil

local function GetCharacterComponents()
	local Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
	local Humanoid = Character:FindFirstChild("Humanoid") or Character:WaitForChild("Humanoid")
	local HumanoidRootPart
	repeat
		HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
		task.wait()
	until HumanoidRootPart
	if not targetReferencePart then
		targetReferencePart = Instance.new("Part")
		targetReferencePart.Name = "TargetReferencePart"
		targetReferencePart.Size = Vector3.new(0.5, 0.5, 0.5)
		targetReferencePart.Transparency = 0.5
		targetReferencePart.CanCollide = false
		targetReferencePart.Anchored = true
		targetReferencePart.Parent = Character
	end
	targetReferencePart.Position = HumanoidRootPart.Position
	return Character, Humanoid, HumanoidRootPart
end

local Character, Humanoid, HumanoidRootPart = GetCharacterComponents()
local bodyGyro = Instance.new("BodyGyro")
bodyGyro.MaxTorque = Vector3.new(0, math.huge, 0)
bodyGyro.P = 10000
bodyGyro.D = 100
bodyGyro.Parent = HumanoidRootPart

local function GetRigType(player)
	if not player or not player.Character then return "None" end
	local humanoid = player.Character:FindFirstChild("Humanoid")
	if not humanoid then return "None" end
	return humanoid.RigType == Enum.HumanoidRigType.R6 and "R6" or "R15"
end

local function UnequipCurrentItem()
	if not BEHAVIORS.ENABLE_ITEM_HANDLING then return end
	if currentEquippedItem then
		local backpack = LocalPlayer:FindFirstChild("Backpack")
		if backpack then
			currentEquippedItem.Parent = backpack
			currentEquippedItem = nil
		end
	end
end

local function EquipRandom()
	if not BEHAVIORS.ENABLE_ITEM_HANDLING then return end
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if not backpack then return end
	local availableItems = {}
	for _, itemName in ipairs(ITEMS_TO_EQUIP) do
		local item = backpack:FindFirstChild(itemName)
		if item then
			table.insert(availableItems, item)
		end
	end
	if #availableItems > 0 then
		if currentEquippedItem then
			currentEquippedItem.Parent = backpack
		end
		local randomItem = availableItems[math.random(1, #availableItems)]
		randomItem.Parent = Character
		currentEquippedItem = randomItem
		lastItemSwitch = tick()
	end
end

local function ItemHandler()
	if not BEHAVIORS.ENABLE_ITEM_HANDLING then return end
	if not beingLookedAt then
		UnequipCurrentItem()
		return
	end
	local timeSinceLastSwitch = tick() - lastItemSwitch
	local randomInterval = ITEM_SWITCH_INTERVAL_MIN + (math.random() * (ITEM_SWITCH_INTERVAL_MAX - ITEM_SWITCH_INTERVAL_MIN))
	if timeSinceLastSwitch >= randomInterval then
		EquipRandom()
	end
	if currentEquippedItem and tick() - lastActivateCheck >= TOOL_ACTIVATE_CHECK_INTERVAL then
		lastActivateCheck = tick()
		if math.random() <= TOOL_ACTIVATE_CHANCE then
			if typeof(currentEquippedItem.Activate) == "function" then
				pcall(function()
					currentEquippedItem:Activate()
				end)
			end
		end
	end
end

local function HandleSeatedState()
	if not BEHAVIORS.ENABLE_SEAT_HANDLING then return end
	local currentTime = tick()
	if LocalPlayer.Character and LocalPlayer.Character.Humanoid.Sit and currentTime - lastSeatChange > 1 then
		LocalPlayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
		task.wait()
		LocalPlayer.Character.Humanoid.Jump = true
		lastSeatChange = currentTime
	end
end

local function GetNearestPlayer()
	-- If a manual target is set and valid, return it
	if manualTargetSelected and currentTarget and currentTarget.Character then
		local hum = currentTarget.Character:FindFirstChild("Humanoid")
		local root = currentTarget.Character:FindFirstChild("HumanoidRootPart")
		if hum and root and hum.Health > 0 then
			return currentTarget
		else
			manualTargetSelected = false
			currentTarget = nil
		end
	end

	if not BEHAVIORS.ENABLE_AUTO_TARGET then
		if DEBUG_MODE then
			for _, player in ipairs(Players:GetPlayers()) do
				if player.Name == DEBUG_TARGET_PLAYER_NAME and player.Character then
					local targetHumanoid = player.Character:FindFirstChild("Humanoid")
					local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
					if targetRoot and targetHumanoid and targetHumanoid.Health > 0 then
						currentTarget = player
						return currentTarget
					end
				end
			end
		end
		return nil
	end

	local currentTime = tick()
	if currentTarget and currentTime - lastTargetSwitch > TARGET_SWITCH_TIME_MAX then
		currentTarget = nil
	end

	local validTargets = {}
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			local targetHumanoid = player.Character:FindFirstChild("Humanoid")
			local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")

			if targetRoot and targetHumanoid and targetHumanoid.Health > 0 then
				local distance = (targetRoot.Position - targetReferencePart.Position).Magnitude
				if distance <= LOOK_DETECTION_RADIUS then
					table.insert(validTargets, {
						player = player,
						distance = distance
					})
				end
			end
		end
	end
	if #validTargets > 0 and (not currentTarget or currentTime - lastTargetSwitch >= TARGET_SWITCH_TIME_MIN) then
		table.sort(validTargets, function(a, b)
			return a.distance < b.distance
		end)
		local selectionPool = math.min(3, #validTargets)
		if selectionPool > 0 then
			local selectedIndex = math.random(1, selectionPool)
			currentTarget = validTargets[selectedIndex].player
			lastTargetSwitch = currentTime
			targetSwitchDelay = TARGET_SWITCH_TIME_MIN + (math.random() * (TARGET_SWITCH_TIME_MAX - TARGET_SWITCH_TIME_MIN))
		end
	end
	return currentTarget, currentTarget == nil
end

local function IsTargetLookingAtMe(target)
	local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
	if not targetRoot or not targetReferencePart then return false end
	local distance = (targetRoot.Position - targetReferencePart.Position).Magnitude
	if distance > LOOK_DETECTION_RADIUS then 
		return false 
	end
	local toLocal = (targetReferencePart.Position - targetRoot.Position).Unit
	local targetLook = targetRoot.CFrame.LookVector
	local angle = math.acos(toLocal:Dot(targetLook))
	return angle < LOOK_ANGLE_THRESHOLD
end

local function GetPositionBehindTarget(target)
	local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
	if not targetRoot then return nil end
	local targetCFrame = targetRoot.CFrame
	return targetCFrame.Position - (targetCFrame.LookVector * BACK_DISTANCE)
end

local function GetPositionInFrontOfTarget(target)
	local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
	if not targetRoot then return nil end
	local targetCFrame = targetRoot.CFrame
	return targetCFrame.Position + (targetCFrame.LookVector * FRONT_DISTANCE)
end

local function GetRandomPositionInRadius(centerPosition)
	if not centerPosition then return nil end
	local angle = math.random() * math.pi
	local distance = math.random() * RADIUS
	local offset = Vector3.new(
		math.cos(angle) * distance,
		0,
		math.sin(angle) * distance
	)
	return centerPosition + offset
end

local function GetClosePosition(target)
	if not target or not target.Character then return nil end
	local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
	if not targetRoot or not targetReferencePart then return nil end

	local randomDistance = CLOSE_DISTANCE_MIN + (math.random() * (CLOSE_DISTANCE_MAX - CLOSE_DISTANCE_MIN))
	local targetPos = targetRoot.Position
	local myPos = targetReferencePart.Position
	local direction = (targetPos - myPos).Unit
	return targetPos - (direction * randomDistance)
end

local function MoveToPosition(position)
	if not position or isMoving then return end
	isMoving = true
	Humanoid.WalkToPoint = position
	local startTime = tick()
	local timeout = 0.05
	while (HumanoidRootPart.Position - position).Magnitude > 0.5 do
		if tick() - startTime > timeout then
			break
		end
		task.wait()
	end
	isMoving = false
end

local function StartFrontMovement()
	if not BEHAVIORS.ENABLE_FRONT_MOVEMENT then return end
	if isFrontMovementEnabled then return end
	isFrontMovementEnabled = true
	isMovingBackward = false
	task.spawn(function()
		while isFrontMovementEnabled do
			local nearestPlayer = GetNearestPlayer()
			if nearestPlayer and IsTargetLookingAtMe(nearestPlayer) then
				local frontPosition = GetPositionInFrontOfTarget(nearestPlayer)
				local targetPosition = GetRandomPositionInRadius(frontPosition)
				if targetPosition then
					MoveToPosition(targetPosition)
				end
				local closePosition = GetClosePosition(nearestPlayer)
				if closePosition then
					MoveToPosition(closePosition)
				end
			end
			task.wait(timeout)
		end
	end)
end

local function StopFrontMovement()
	isFrontMovementEnabled = false
end

local function StartBackMovement()
	if not BEHAVIORS.ENABLE_BACK_MOVEMENT then return end
	if isMovingBack then return end
	isMovingBack = true
	isMovingBackward = true
	task.spawn(function()
		while isMovingBack do
			local nearestPlayer = GetNearestPlayer()
			if nearestPlayer then
				local behindPosition = GetPositionBehindTarget(nearestPlayer)
				local targetPosition = GetRandomPositionInRadius(behindPosition)
				if targetPosition then
					MoveToPosition(targetPosition)
				end
				local closePosition = GetClosePosition(nearestPlayer)
				if closePosition then
					MoveToPosition(closePosition)
				end
			end
			task.wait(timeout)
		end
	end)
end

local function StopBackMovement()
	isMovingBack = false
	isMovingBackward = false
end

local function StopInching()
	isInchingEnabled = false
end

local function PerformJump()
	Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
	isJumping = true
	lastJumpTime = tick()
	Humanoid.Jump = true

	task.delay(0.1, function()
		isJumping = false
	end)
end

local function PerformInchMovement(target, backwards)
	if not BEHAVIORS.ENABLE_INCHING then return end
	if inchingInProgress then return end
	local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
	if not targetRoot or not targetReferencePart then return end
	local currentDistance = (targetRoot.Position - targetReferencePart.Position).Magnitude
	if backwards then
		if currentDistance >= BACKWARDS_MINIMUM_DISTANCE then return end
		local direction = (targetReferencePart.Position - targetRoot.Position).Unit
		local moveAmount = math.min(BACKWARDS_INCH_AMOUNT, BACKWARDS_MINIMUM_DISTANCE - currentDistance)
		local newPosition = targetReferencePart.Position + (direction * moveAmount)
		inchingInProgress = true
		Humanoid.WalkToPoint = newPosition
	else
		if currentDistance <= MINIMUM_DISTANCE_TO_TARGET then 
			if math.random() <= MINIMUM_DISTANCE_BEHAVIOR.FRONT_MOVEMENT_SWITCH_CHANCE then
				StopInching()
				StartFrontMovement()
			end
			return 
		end
		local direction = (targetRoot.Position - targetReferencePart.Position).Unit
		local moveAmount = math.min(INCH_AMOUNT, currentDistance - MINIMUM_DISTANCE_TO_TARGET)
		local newPosition = targetReferencePart.Position + (direction * moveAmount)
		inchingInProgress = true
		Humanoid.WalkToPoint = newPosition
	end
	local startTime = tick()
	while (HumanoidRootPart.Position - Humanoid.WalkToPoint).Magnitude > 0.5 do
		if tick() - startTime > 1 then break end
		task.wait()
	end
	inchingInProgress = false
	lastInchTime = tick()
	task.wait(0.1)
end

local function StartInching(backwards)
	if not BEHAVIORS.ENABLE_INCHING then return end
	if isInchingEnabled then return end
	isInchingEnabled = true
	local initialWaitTime = INITIAL_WAIT_MIN + (math.random() * (INITIAL_WAIT_MAX - INITIAL_WAIT_MIN))
	task.wait(initialWaitTime)
	task.spawn(function()
		while isInchingEnabled do
			local nearestPlayer = GetNearestPlayer()
			if nearestPlayer and IsTargetLookingAtMe(nearestPlayer) then
				local timeSinceLastInch = tick() - lastInchTime
				local randomInterval = INCH_INTERVAL_MIN + (math.random() * (INCH_INTERVAL_MAX - INCH_INTERVAL_MIN))
				if timeSinceLastInch >= randomInterval then
					PerformInchMovement(nearestPlayer, backwards)
				end
			end
			task.wait(0.1)
		end
	end)
end

local function TrackTargetMovement(target)
	if not BEHAVIORS.ENABLE_PATTERN_DETECTION then return end
	if not target or not target.Character then return end
	local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
	if not targetRoot then return end
	local currentPosition = targetRoot.Position
	if lastTargetPosition then
		local distanceMoved = (currentPosition - lastTargetPosition).Magnitude
		if distanceMoved and 
			PATTERN_DETECTION.SMALL_RANGE and 
			PATTERN_DETECTION.SMALL_RANGE.min and 
			PATTERN_DETECTION.SMALL_RANGE.max then
			table.insert(movementHistory, distanceMoved)
			if #movementHistory > PATTERN_DETECTION.HISTORY_LENGTH then
				table.remove(movementHistory, 1)
			end
			if distanceMoved >= PATTERN_DETECTION.SMALL_RANGE.min and 
				distanceMoved <= PATTERN_DETECTION.SMALL_RANGE.max then
				smallRangeCount = (smallRangeCount or 0) + 1
			elseif distanceMoved >= PATTERN_DETECTION.LARGE_RANGE.min and 
				distanceMoved <= PATTERN_DETECTION.LARGE_RANGE.max then
				largeRangeCount = (largeRangeCount or 0) + 1
			else
				smallRangeCount = 0
				largeRangeCount = 0
			end
			if (smallRangeCount and smallRangeCount >= PATTERN_DETECTION.THRESHOLD) or 
				(largeRangeCount and largeRangeCount >= PATTERN_DETECTION.THRESHOLD) then
				smallRangeCount = 0
				largeRangeCount = 0
				StartFrontMovement()
			end
		end
	end
	lastTargetPosition = currentPosition
end

local function StopToolAnimation(animator)
	if not animator then return end

	if BOOMBOX_CONFIG.animationConnection then
		BOOMBOX_CONFIG.animationConnection:Disconnect()
		BOOMBOX_CONFIG.animationConnection = nil
	end
	if BOOMBOX_CONFIG.animatorConnection then
		BOOMBOX_CONFIG.animatorConnection:Disconnect()
		BOOMBOX_CONFIG.animatorConnection = nil
	end
	for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
		if track.Animation and 
			(string.match(track.Animation.Name:lower(), "tool") or 
				string.match(track.Animation.Name:lower(), "item")) then
			track:Stop()
			BOOMBOX_CONFIG.toolAnimTrack = track
		end
	end
	BOOMBOX_CONFIG.animatorConnection = animator.AnimationPlayed:Connect(function(track)
		if track.Animation and 
			(string.match(track.Animation.Name:lower(), "tool") or 
				string.match(track.Animation.Name:lower(), "item")) then
			track:Stop()
			BOOMBOX_CONFIG.toolAnimTrack = track
		end
	end)
end

local function ResumeToolAnimation(animator)
	if not animator then return end

	if BOOMBOX_CONFIG.animationConnection then
		BOOMBOX_CONFIG.animationConnection:Disconnect()
		BOOMBOX_CONFIG.animationConnection = nil
	end
	if BOOMBOX_CONFIG.animatorConnection then
		BOOMBOX_CONFIG.animatorConnection:Disconnect()
		BOOMBOX_CONFIG.animatorConnection = nil
	end
end

local function UnequipBoomBox()
	if BOOMBOX_CONFIG.currentBoomBox then
		local backpack = LocalPlayer:FindFirstChild("Backpack")
		if backpack then
			if BOOMBOX_CONFIG.animationConnection then
				BOOMBOX_CONFIG.animationConnection:Disconnect()
				BOOMBOX_CONFIG.animationConnection = nil
			end
			if BOOMBOX_CONFIG.animatorConnection then
				BOOMBOX_CONFIG.animatorConnection:Disconnect()
				BOOMBOX_CONFIG.animatorConnection = nil
			end
			if BOOMBOX_CONFIG.toolAnimTrack then
				BOOMBOX_CONFIG.toolAnimTrack:Stop()
				BOOMBOX_CONFIG.toolAnimTrack = nil
			end
			local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
			if humanoid then
				local animator = humanoid:FindFirstChild("Animator")
				if animator then
					ResumeToolAnimation(animator)
					for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
						if track.Animation and 
							(string.match(track.Animation.Name:lower(), "tool") or 
								string.match(track.Animation.Name:lower(), "item")) then
							track:Play()
						end
					end
				end
			end
			BOOMBOX_CONFIG.currentBoomBox.Parent = backpack
			BOOMBOX_CONFIG.currentBoomBox = nil
		end
	end
end

local function HandleBoomBox(nearestPlayer)
	if not BEHAVIORS.ENABLE_BOOMBOX then
		UnequipBoomBox()
		return
	end
	if tick() - BOOMBOX_CONFIG.lastBoomBoxCheck < BOOMBOX_CONFIG.CHECK_INTERVAL then return end
	BOOMBOX_CONFIG.lastBoomBoxCheck = tick()

	if not nearestPlayer or not nearestPlayer.Character then 
		UnequipBoomBox()
		return
	end
	local targetRoot = nearestPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not targetRoot then 
		UnequipBoomBox()
		return 
	end
	local distance = (targetRoot.Position - targetReferencePart.Position).Magnitude
	local isValidState = currentBehaviorState == "frontshots" or currentBehaviorState == "backshots"
	if distance <= BOOMBOX_CONFIG.RADIUS and isValidState then
		if not BOOMBOX_CONFIG.currentBoomBox then
			local backpack = LocalPlayer:FindFirstChild("Backpack")
			if not backpack then return end
			local boomBox = backpack:FindFirstChild("BoomBox") or backpack:FindFirstChild("Boombox")
			if boomBox then
				boomBox.GripPos = BOOMBOX_CONFIG.GRIP_POS
				local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
				if humanoid then
					local animator = humanoid:FindFirstChild("Animator")
					if animator then
						StopToolAnimation(animator)
					end
				end
				boomBox.Parent = LocalPlayer.Character
				BOOMBOX_CONFIG.currentBoomBox = boomBox
				boomBox.Handle.Massless = true
				task.wait()
				local remote = boomBox:FindFirstChild("Remote")
				if remote then
					remote:FireServer("PlaySong", tonumber(BOOMBOX_CONFIG.SOUND_ID))
				end
			end
		end
	else
		UnequipBoomBox()
	end
end

local function CreateHUD()
	if behaviorScreenGui and behaviorScreenGui.Parent then
		pcall(function() behaviorScreenGui:Destroy() end)
		behaviorScreenGui = nil
	end

	local playerGui = LocalPlayer:WaitForChild("PlayerGui")
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "BehaviorHUD"
	screenGui.ResetOnSpawn = false
	screenGui.Parent = playerGui

	local frame = Instance.new("Frame")
	frame.Name = "BehaviorFrame"
	frame.Size = UDim2.new(0, 280, 0, 220) -- smaller
	frame.Position = UDim2.new(0.78, 0, 0.08, 0)
	frame.AnchorPoint = Vector2.new(0.5, 0)
	frame.BackgroundColor3 = Color3.fromRGB(38, 38, 38)
	frame.BorderSizePixel = 0
	frame.Parent = screenGui
	frame.Active = true

	local header = Instance.new("TextLabel")
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 30)
	header.Position = UDim2.new(0, 0, 0, 0)
	header.BackgroundColor3 = Color3.fromRGB(28, 28, 28)
	header.BorderSizePixel = 0
	header.Text = "FE Backshot"
	header.Font = Enum.Font.Code
	header.TextSize = 16
	header.TextColor3 = Color3.fromRGB(255, 255, 255)
	header.Parent = frame

	local content = Instance.new("ScrollingFrame")
	content.Name = "Content"
	content.Size = UDim2.new(1, -12, 1, -98)
	content.Position = UDim2.new(0, 6, 0, 36)
	content.BackgroundTransparency = 1
	content.ScrollBarThickness = 8
	content.Parent = frame

	local uiLayout = Instance.new("UIGridLayout")
	uiLayout.CellSize = UDim2.new(0.48, 0, 0, 30)
	uiLayout.CellPadding = UDim2.new(0, 6, 0, 6)
	uiLayout.FillDirection = Enum.FillDirection.Vertical
	uiLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	uiLayout.Parent = content

	local function addToggle(name, enabled)
		local container = Instance.new("Frame")
		container.Size = UDim2.new(1, 0, 0, 30)
		container.BackgroundTransparency = 1
		container.Parent = content

		local btn = Instance.new("TextButton")
		btn.Size = UDim2.new(0, 30, 1, 0)
		btn.Position = UDim2.new(0, 4, 0, 0)
		btn.Text = ""
		btn.BackgroundColor3 = enabled and Color3.fromRGB(30, 200, 30) or Color3.fromRGB(200, 30, 30)
		btn.BorderSizePixel = 0
		btn.Parent = container

		local lbl = Instance.new("TextLabel")
		lbl.Size = UDim2.new(1, -40, 1, 0)
		lbl.Position = UDim2.new(0, 40, 0, 0)
		lbl.BackgroundTransparency = 1
		lbl.Text = name
		lbl.Font = Enum.Font.Code
		lbl.TextSize = 13
		lbl.TextColor3 = Color3.fromRGB(230, 230, 230)
		lbl.TextXAlignment = Enum.TextXAlignment.Left
		lbl.Parent = container

		btn.MouseButton1Click:Connect(function()
			BEHAVIORS[name] = not BEHAVIORS[name]
			btn.BackgroundColor3 = BEHAVIORS[name] and Color3.fromRGB(30, 200, 30) or Color3.fromRGB(200, 30, 30)
			if not BEHAVIORS[name] then
				if name == "ENABLE_BACK_MOVEMENT" then
					StopBackMovement()
				elseif name == "ENABLE_FRONT_MOVEMENT" then
					StopFrontMovement()
				elseif name == "ENABLE_INCHING" then
					StopInching()
				elseif name == "ENABLE_ITEM_HANDLING" then
					UnequipCurrentItem()
				elseif name == "ENABLE_BOOMBOX" then
					UnequipBoomBox()
				end
			end
		end)
	end

	for k, v in pairs(BEHAVIORS) do
		addToggle(k, v)
	end

	local debugFrame = Instance.new("Frame")
	debugFrame.Size = UDim2.new(1, -12, 0, 66)
	debugFrame.Position = UDim2.new(0, 6, 1, -98)
	debugFrame.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
	debugFrame.BorderSizePixel = 0
	debugFrame.Parent = frame

	local debugLbl = Instance.new("TextLabel")
	debugLbl.Size = UDim2.new(1, -12, 1, -12)
	debugLbl.Position = UDim2.new(0, 6, 0, 6)
	debugLbl.BackgroundTransparency = 1
	debugLbl.Font = Enum.Font.Code
	debugLbl.TextSize = 12
	debugLbl.TextColor3 = Color3.fromRGB(220, 220, 220)
	debugLbl.TextWrapped = true
	debugLbl.TextYAlignment = Enum.TextYAlignment.Top
	debugLbl.TextXAlignment = Enum.TextXAlignment.Left
	debugLbl.Parent = debugFrame

	local bottom = Instance.new("Frame")
	bottom.Size = UDim2.new(1, -12, 0, 28)
	bottom.Position = UDim2.new(0, 6, 1, -30)
	bottom.BackgroundTransparency = 1
	bottom.Parent = frame

	local giveBack = Instance.new("TextButton")
	giveBack.Size = UDim2.new(0.34, -6, 1, 0)
	giveBack.Position = UDim2.new(0, 0, 0, 0)
	giveBack.Text = "Give Back"
	giveBack.Font = Enum.Font.Code
	giveBack.TextSize = 12
	giveBack.Parent = bottom

	local giveFront = Instance.new("TextButton")
	giveFront.Size = UDim2.new(0.33, -6, 1, 0)
	giveFront.Position = UDim2.new(0.34, 6, 0, 0)
	giveFront.Text = "Give Front"
	giveFront.Font = Enum.Font.Code
	giveFront.TextSize = 12
	giveFront.Parent = bottom

	local clearBtn = Instance.new("TextButton")
	clearBtn.Size = UDim2.new(0.33, -6, 1, 0)
	clearBtn.Position = UDim2.new(0.67, 12, 0, 0)
	clearBtn.Text = "Clear"
	clearBtn.Font = Enum.Font.Code
	clearBtn.TextSize = 12
	clearBtn.Parent = bottom

	local dragging = false
	local dragInput, dragStart, startPos
	local function update(input)
		local delta = input.Position - dragStart
		local newX = startPos.X.Offset + delta.X
		local newY = startPos.Y.Offset + delta.Y
		frame.Position = UDim2.new(startPos.X.Scale, newX, startPos.Y.Scale, newY)
	end

	header.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = frame.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)

	header.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement then
			dragInput = input
		end
	end)

	UserInputService.InputChanged:Connect(function(input)
		if input == dragInput and dragging then
			update(input)
		end
	end)

	return debugLbl, screenGui, giveBack, giveFront, clearBtn
end

local function SetManualTarget(player, mode)
	if not player or not player.Character then return end
	currentTarget = player
	manualTargetSelected = true
	preferredShotMode = (mode == "front") and "front" or "back"
	lastTargetSwitch = tick()
	if debugTextLabel then
		debugTextLabel.Text = ("Manual target set: %s (%s)\n"):format(player.Name, preferredShotMode) .. (debugTextLabel.Text or "")
	end
end

local function FaceAwayAndClear(target)
	if not HumanoidRootPart or not Humanoid then return end

	if target and target.Character then
		local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
		if targetRoot then
			isMoving = false
			inchingInProgress = false
			pcall(function() Humanoid:MoveTo(HumanoidRootPart.Position) end)
			Humanoid.WalkToPoint = HumanoidRootPart.Position

			local awayDir = (HumanoidRootPart.Position - targetRoot.Position)
			if awayDir.Magnitude > 0 then
				awayDir = awayDir.Unit
				local awayPos = HumanoidRootPart.Position + awayDir
				bodyGyro.CFrame = CFrame.new(HumanoidRootPart.Position, Vector3.new(awayPos.X, HumanoidRootPart.Position.Y, awayPos.Z))
			end
		end
	end

	manualTargetSelected = false
	currentTarget = nil
	preferredShotMode = "back"

	if debugTextLabel then
		debugTextLabel.Text = "Tool unequipped: target cleared & faced away.\n" .. (debugTextLabel.Text or "")
	end
end

local function ClearManualTarget()
	manualTargetSelected = false
	currentTarget = nil
	preferredShotMode = "back"
	if debugTextLabel then
		debugTextLabel.Text = "Manual target cleared.\n" .. (debugTextLabel.Text or "")
	end
end

local function GiveTargetPickerTool(mode)
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if not backpack then return end

	local toolName = "TargetPicker_"..mode
	local existing = backpack:FindFirstChild(toolName) or (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild(toolName))
	if existing then
		existing.Parent = backpack
		if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
			pcall(function() LocalPlayer.Character.Humanoid:EquipTool(existing) end)
		end
		return existing
	end

	local tool = Instance.new("Tool")
	tool.Name = toolName
	tool.RequiresHandle = false -- NO handle
	tool.CanBeDropped = true
	tool.Parent = backpack

	local mouse = LocalPlayer:GetMouse()

	tool.Activated:Connect(function()
		local targetPart = mouse.Target
		if not targetPart then return end
		local characterModel = targetPart:FindFirstAncestorWhichIsA("Model")
		if not characterModel then return end
		local targetPlayer = Players:GetPlayerFromCharacter(characterModel)
		if targetPlayer and targetPlayer ~= LocalPlayer then
			if currentTarget and targetPlayer == currentTarget then
				-- pressed same target again -> stop & face instantly
				isMoving = false
				inchingInProgress = false
				pcall(function() Humanoid:MoveTo(HumanoidRootPart.Position) end)
				Humanoid.WalkToPoint = HumanoidRootPart.Position
				local targetRoot = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
				if targetRoot then
					bodyGyro.CFrame = CFrame.new(HumanoidRootPart.Position, Vector3.new(targetRoot.Position.X, HumanoidRootPart.Position.Y, targetRoot.Position.Z))
				end
				if debugTextLabel then
					debugTextLabel.Text = ("Stopped & faced target: %s\n"):format(targetPlayer.Name) .. (debugTextLabel.Text or "")
				end
			else
				SetManualTarget(targetPlayer, mode)
				if preferredShotMode == "front" then
					StopBackMovement()
					StartFrontMovement()
					currentBehaviorState = "frontshots"
				else
					StopFrontMovement()
					StartBackMovement()
					currentBehaviorState = "backshots"
				end
			end
		end
	end)

	tool.Unequipped:Connect(function()
		FaceAwayAndClear(currentTarget)
		pcall(function()
			if tool and tool.Parent and not tool.Parent:IsA("Backpack") then
				tool.Parent = backpack
			end
		end)
	end)

	task.defer(function()
		task.wait(0.05)
		if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
			pcall(function()
				LocalPlayer.Character.Humanoid:EquipTool(tool)
			end)
		end
	end)

	return tool
end

debugTextLabel, behaviorScreenGui, giveBackToolBtn, giveFrontToolBtn, clearTargetBtn = CreateHUD()
if giveBackToolBtn then
	giveBackToolBtn.MouseButton1Click:Connect(function()
		GiveTargetPickerTool("back")
	end)
end
if giveFrontToolBtn then
	giveFrontToolBtn.MouseButton1Click:Connect(function()
		GiveTargetPickerTool("front")
	end)
end
if clearTargetBtn then
	clearTargetBtn.MouseButton1Click:Connect(function()
		ClearManualTarget()
	end)
end

local function UpdateBillboardUI()
	if debugTextLabel then
		local behaviorText = string.format(
			"Behavior State: %s\n" ..
				"Target: %s\n" ..
				"moving: %s\n" ..
				"frontshots: %s\n" ..
				"backshots: %s\n" ..
				"being looked at: %s\n" ..
				"inching: %s\n" ..
				"item: %s\n" ..
				"jumping: %s\n" ..
				"target rig: %s\n",
			currentBehaviorState,
			currentTarget and currentTarget.Name or "None",
			tostring(isMoving),
			tostring(isFrontMovementEnabled),
			tostring(isMovingBack),
			tostring(beingLookedAt),
			tostring(isInchingEnabled),
			currentEquippedItem and currentEquippedItem.Name or "None",
			tostring(isJumping),
			currentTarget and GetRigType(currentTarget) or "None"
		)
		debugTextLabel.Text = behaviorText
	end
end

local function UpdatePlayerMovementHistory(player)
	if not player.Character then return end
	local root = player.Character:FindFirstChild("HumanoidRootPart")
	if not root then return end
	if not playerMovementHistory[player] then
		playerMovementHistory[player] = {
			positions = {},
			directionChanges = 0,
			lastDirection = nil
		}
	end
	local history = playerMovementHistory[player]
	local currentPos = root.Position
	table.insert(history.positions, currentPos)
	if #history.positions > PATTERN_DETECTION.HISTORY_LENGTH then
		table.remove(history.positions, 1)
	end
	if #history.positions >= 3 then
		local prev = history.positions[#history.positions - 2]
		local current = history.positions[#history.positions - 1]
		local next = history.positions[#history.positions]
		local prevVector = (current - prev).Unit
		local nextVector = (next - current).Unit
		if prevVector:Dot(nextVector) < 0 and 
			(next - prev).Magnitude > PATTERN_DETECTION.DIRECTION_CHANGE_THRESHOLD then
			history.directionChanges = history.directionChanges + 1
		end
	end
	if tick() - (history.lastCheck or 0) > PATTERN_DETECTION.CHECK_INTERVAL * PATTERN_DETECTION.HISTORY_LENGTH then
		history.directionChanges = 0
	end
	history.lastCheck = tick()
end

local function pattern()
	if tick() - lastPatternCheck < PATTERN_DETECTION.MOVEMENT_CHECK_INTERVAL then return end
	lastPatternCheck = tick()
	local nearbyPlayers = {}
	local mostActivePlayer = nil
	local highestDirectionChanges = 0
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			local root = player.Character:FindFirstChild("HumanoidRootPart")
			if root and (root.Position - targetReferencePart.Position).Magnitude <= PATTERN_DETECTION.NEARBY_PLAYER_RADIUS then
				UpdatePlayerMovementHistory(player)
				local history = playerMovementHistory[player]
				if history and history.directionChanges > highestDirectionChanges then
					highestDirectionChanges = history.directionChanges
					mostActivePlayer = player
				end
				table.insert(nearbyPlayers, player)
			end
		end
	end
	for _, player in ipairs(nearbyPlayers) do
		local history = playerMovementHistory[player]
		if history and history.directionChanges >= PATTERN_DETECTION.PATTERN_THRESHOLD then
			if currentTarget == player and tick() - lastTargetSwitch > PATTERN_DETECTION.TARGET_SWITCH_DELAY then
				currentTarget = player
				lastTargetSwitch = tick()
				playerMovementHistory = {}
				return
			end
		end
	end
end

local function EvaluateBehaviors()
	local nearestPlayer = GetNearestPlayer()
	if not nearestPlayer then return end
	local isBeingLookedAt = IsTargetLookingAtMe(nearestPlayer)
	if isBeingLookedAt then
		if math.random() <= IGNORE_GAZE_CHANCE then
			StopInching()
			StopFrontMovement()
			StartBackMovement()
		else
			if math.random() <= REACTION_CHANCE then
				if math.random() <= FRONT_MOVEMENT_CHANCE and BEHAVIORS.ENABLE_FRONT_MOVEMENT then
					StopInching()
					StopBackMovement()
					StartFrontMovement()
				else
					StopFrontMovement()
					StopBackMovement()
					isReverseBehavior = math.random() <= REVERSE_BEHAVIOR_CHANCE
					StartInching(isReverseBehavior)
				end
			end
		end
	else
		StopInching()
		StopFrontMovement()
		StartBackMovement()
	end

	local targetRoot = nearestPlayer.Character and nearestPlayer.Character:FindFirstChild("HumanoidRootPart")
	if targetRoot then
		if manualTargetSelected and preferredShotMode == "front" then
			if isBeingLookedAt and math.random() <= LOOKAT_CHANCE then
				bodyGyro.CFrame = CFrame.new(HumanoidRootPart.Position, Vector3.new(targetRoot.Position.X, HumanoidRootPart.Position.Y, targetRoot.Position.Z))
			else
				local awayDir = (HumanoidRootPart.Position - targetRoot.Position).Unit
				local awayPos = HumanoidRootPart.Position + awayDir
				bodyGyro.CFrame = CFrame.new(HumanoidRootPart.Position, Vector3.new(awayPos.X, HumanoidRootPart.Position.Y, awayPos.Z))
			end
		else
			if isBeingLookedAt then
				if math.random() <= LOOKAT_CHANCE then
					bodyGyro.CFrame = CFrame.new(HumanoidRootPart.Position, Vector3.new(targetRoot.Position.X, HumanoidRootPart.Position.Y, targetRoot.Position.Z))
				end
			else
				if math.random() <= LOOKAWAY_CHANCE then
					local awayDir = (HumanoidRootPart.Position - targetRoot.Position).Unit
					local awayPos = HumanoidRootPart.Position + awayDir
					bodyGyro.CFrame = CFrame.new(HumanoidRootPart.Position, Vector3.new(awayPos.X, HumanoidRootPart.Position.Y, awayPos.Z))
				else
					bodyGyro.CFrame = CFrame.new(HumanoidRootPart.Position, Vector3.new(targetRoot.Position.X, HumanoidRootPart.Position.Y, targetRoot.Position.Z))
				end
			end
		end
	end
end

local function IsPartOfCharacter(instance)
	local model = instance:FindFirstAncestorWhichIsA("Model")
	return model and Players:GetPlayerFromCharacter(model) ~= nil
end

local function IsToolOrThang(instance)
	if instance:IsA("Tool") or (instance.Parent and instance.Parent:IsA("Tool")) then
		return true
	end
	if instance:IsA("Accessory") or (instance.Parent and instance.Parent:IsA("Accessory")) then
		return true
	end
	local accessory = instance:FindFirstAncestorWhichIsA("Accessory")
	if accessory then
		return true
	end
	return false
end

local function obstacleCheck()
	if not HumanoidRootPart or not Humanoid then return end
	if isJumping or Humanoid.Jump then return end
	local currentTime = tick()
	if currentTime - lastJumpTime < RAYCAST_CONFIG.JUMP_COOLDOWN then return end
	local raycastParams = RaycastParams.new()
	raycastParams.FilterType = RAYCAST_CONFIG.FILTER_TYPE
	local filterInstances = {}
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Character then
			table.insert(filterInstances, player.Character)
		end
	end
	if LocalPlayer.Character then
		for _, item in ipairs(LocalPlayer.Character:GetChildren()) do
			if item:IsA("Tool") or item:IsA("Accessory") then
				table.insert(filterInstances, item)
			end
		end
	end
	raycastParams.FilterDescendantsInstances = filterInstances
	local checks = {
		{offset = Vector3.new(0, RAYCAST_CONFIG.HEIGHT_OFFSET, 0), distance = RAYCAST_CONFIG.DISTANCE},
		{offset = Vector3.new(-0.5, RAYCAST_CONFIG.HEIGHT_OFFSET, 0), distance = RAYCAST_CONFIG.DISTANCE},
		{offset = Vector3.new(0.5, RAYCAST_CONFIG.HEIGHT_OFFSET, 0), distance = RAYCAST_CONFIG.DISTANCE}
	}
	for _, check in ipairs(checks) do
		local startPos = HumanoidRootPart.Position + check.offset
		local lookVector = HumanoidRootPart.CFrame.LookVector
		local endPos = startPos + (lookVector * check.distance)
		local result = workspace:Raycast(startPos, endPos - startPos, raycastParams)

		if result then
			local hitPart = result.Instance
			if not IsPartOfCharacter(hitPart) and not IsToolOrThang(hitPart) then
				PerformJump()
				return
			end
		end
	end
	if currentTime - STUCK_DETECTION.LAST_CHECK_TIME >= STUCK_DETECTION.CHECK_INTERVAL then
		STUCK_DETECTION.LAST_CHECK_TIME = currentTime
		if Humanoid.MoveDirection.Magnitude > 0 and not beingLookedAt then
			local currentPosition = HumanoidRootPart.Position
			if STUCK_DETECTION.LAST_POSITION then
				local movement = (currentPosition - STUCK_DETECTION.LAST_POSITION).Magnitude
				if movement < STUCK_DETECTION.VELOCITY_THRESHOLD then
					if not STUCK_DETECTION.IS_STUCK then
						STUCK_DETECTION.IS_STUCK = true
						STUCK_DETECTION.STUCK_START_TIME = currentTime
					elseif currentTime - STUCK_DETECTION.STUCK_START_TIME >= STUCK_DETECTION.STUCK_DURATION and
						currentTime - STUCK_DETECTION.LAST_FORCED_JUMP >= STUCK_DETECTION.JUMP_COOLDOWN then
						PerformJump()
						STUCK_DETECTION.LAST_FORCED_JUMP = currentTime
					end
				else
					STUCK_DETECTION.IS_STUCK = false
				end
			end
			STUCK_DETECTION.LAST_POSITION = currentPosition
		else
			STUCK_DETECTION.IS_STUCK = false
		end
	end
end

RunService.Heartbeat:Connect(function()
	if not Humanoid or Humanoid.Health <= 0 then return end
	if targetReferencePart and HumanoidRootPart then
		targetReferencePart.Position = HumanoidRootPart.Position
	end
	if Humanoid.MoveDirection.Magnitude > 0 then
		obstacleCheck()
	else
		STUCK_DETECTION.IS_STUCK = false
		STUCK_DETECTION.LAST_POSITION = nil
	end

	UpdateBillboardUI()
	HandleSeatedState()

	if BEHAVIORS.ENABLE_PATTERN_DETECTION then
		pattern()
	end

	local nearestPlayer = GetNearestPlayer()
	if not nearestPlayer then 
		if currentBehaviorState ~= "idle" then
			currentBehaviorState = "idle"
		end
	
		bodyGyro.CFrame = HumanoidRootPart.CFrame
		StopInching()
		StopFrontMovement()
		StopBackMovement()
		UnequipCurrentItem()
		UnequipBoomBox()
		return 
	end

	if BEHAVIORS.ENABLE_BOOMBOX then
		HandleBoomBox(nearestPlayer)
	end

	if tick() - lastMovementCheck >= PATTERN_DETECTION.MOVEMENT_CHECK_INTERVAL then
		TrackTargetMovement(nearestPlayer)
		lastMovementCheck = tick()
	end

	local targetRoot = nearestPlayer.Character and nearestPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not targetRoot then return end
	local isBeingLookedAt = IsTargetLookingAtMe(nearestPlayer)

	if manualTargetSelected and currentTarget == nearestPlayer and preferredShotMode == "front" and BEHAVIORS.ENABLE_FRONT_MOVEMENT then
		StopBackMovement()
		if not isFrontMovementEnabled then
			StartFrontMovement()
		end
		currentBehaviorState = "frontshots"
		local awayDir = (HumanoidRootPart.Position - targetRoot.Position).Unit
		local awayPos = HumanoidRootPart.Position + awayDir
		bodyGyro.CFrame = CFrame.new(HumanoidRootPart.Position, Vector3.new(awayPos.X, HumanoidRootPart.Position.Y, awayPos.Z))
	else
		if isBeingLookedAt then
			if not beingLookedAt then
				beingLookedAt = true
				EvaluateBehaviors()
			end
			ItemHandler()
			if isFrontMovementEnabled then
				if currentBehaviorState ~= "frontshots" then
					currentBehaviorState = "frontshots"
				end
				local awayDir = (HumanoidRootPart.Position - targetRoot.Position).Unit
				local awayPos = HumanoidRootPart.Position + awayDir
				bodyGyro.CFrame = CFrame.new(HumanoidRootPart.Position, Vector3.new(awayPos.X, HumanoidRootPart.Position.Y, awayPos.Z))
			elseif isReverseBehavior then
				if currentBehaviorState ~= "reversing" then
					currentBehaviorState = "reversing"
				end
				bodyGyro.CFrame = CFrame.new(HumanoidRootPart.Position, Vector3.new(targetRoot.Position.X, HumanoidRootPart.Position.Y, targetRoot.Position.Z))
			else
				if currentBehaviorState ~= "looking away" then
					currentBehaviorState = "looking away"
				end
				local awayDir = (HumanoidRootPart.Position - targetRoot.Position).Unit
				local awayPos = HumanoidRootPart.Position + awayDir
				bodyGyro.CFrame = CFrame.new(HumanoidRootPart.Position, Vector3.new(awayPos.X, HumanoidRootPart.Position.Y, awayPos.Z))
			end
		else
			if beingLookedAt then
				beingLookedAt = false
				isReverseBehavior = false
				StopInching()
				StopFrontMovement()
				StopBackMovement()
				UnequipCurrentItem()
			end
			if currentBehaviorState ~= "backshots" then
				currentBehaviorState = "backshots"
			end
			bodyGyro.CFrame = CFrame.new(HumanoidRootPart.Position, Vector3.new(targetRoot.Position.X, HumanoidRootPart.Position.Y, targetRoot.Position.Z))
			if not (isMoving or inchingInProgress) then
				StartBackMovement()
			end
		end
	end
end)

Players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
	repeat task.wait() until newCharacter:FindFirstChild("HumanoidRootPart")
	Character, Humanoid, HumanoidRootPart = GetCharacterComponents()
	if bodyGyro then
		bodyGyro:Destroy()
	end
	bodyGyro = Instance.new("BodyGyro")
	bodyGyro.MaxTorque = Vector3.new(0, math.huge, 0)
	bodyGyro.P = 10000
	bodyGyro.D = 100
	bodyGyro.Parent = HumanoidRootPart

	if targetReferencePart then
		targetReferencePart:Destroy()
		targetReferencePart = nil
	end

	isMovingBack = true
	isMoving = false
	beingLookedAt = false
	isInchingEnabled = false
	isFrontMovementEnabled = false
	inchingInProgress = false
	currentEquippedItem = nil
	lastItemSwitch = 0
	isReverseBehavior = false
	movementHistory = {}
	smallRangeCount = 0
	largeRangeCount = 0
	lastTargetPosition = nil
	lastJumpAttempt = 0
	jumpAttemptsCount = 0
	currentTarget = nil
	lastJumpTime = 0
	isJumping = false
	manualTargetSelected = false
	preferredShotMode = "back"

	if behaviorScreenGui and behaviorScreenGui.Parent then
		pcall(function() behaviorScreenGui:Destroy() end)
		behaviorScreenGui = nil
	end
	debugTextLabel, behaviorScreenGui, giveBackToolBtn, giveFrontToolBtn, clearTargetBtn = CreateHUD()
	if giveBackToolBtn then
		giveBackToolBtn.MouseButton1Click:Connect(function()
			GiveTargetPickerTool("back")
		end)
	end
	if giveFrontToolBtn then
		giveFrontToolBtn.MouseButton1Click:Connect(function()
			GiveTargetPickerTool("front")
		end)
	end
	if clearTargetBtn then
		clearTargetBtn.MouseButton1Click:Connect(function()
			ClearManualTarget()
		end)
	end
end)
